import { createPagesFunctionHandler } from "@remix-run/cloudflare-pages"
// @ts-ignore - the server build file is generated by `remix vite:build`
import * as build from "../build/server"

const remix = createPagesFunctionHandler({
  build,
})

const MAINTENANCE_STATUS_QUERY = `query MaintenanceStatus {
  maintenanceStatus {
    isMaintenanceModeWeb
    maintenanceMessageWeb
  }
}`

const escapeHtml = (value: string): string => {
  return value
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#39;")
}

const getGraphqlEndpoint = (
  ctx: Parameters<PagesFunction>[0],
): string | null => {
  const env = ctx.env as unknown as Record<string, unknown>
  const remixEndpoint =
    typeof env["VITE_GRAPHQL_ENDPOINT_REMIX"] === "string"
      ? (env["VITE_GRAPHQL_ENDPOINT_REMIX"] as string)
      : null
  const browserEndpoint =
    typeof env["VITE_GRAPHQL_ENDPOINT"] === "string"
      ? (env["VITE_GRAPHQL_ENDPOINT"] as string)
      : null
  return remixEndpoint ?? browserEndpoint ?? null
}

const isHtmlNavigationRequest = (request: Request): boolean => {
  const method = request.method.toUpperCase()
  if (method !== "GET" && method !== "HEAD") return false
  const accept = request.headers.get("accept") ?? ""
  // ブラウザの通常ナビゲーションを主対象にする
  return accept.includes("text/html") || accept.includes("*/*")
}

const getTimeoutSignal = (ms: number): AbortSignal | undefined => {
  const maybe = AbortSignal as unknown as {
    timeout?: (timeoutMs: number) => AbortSignal
  }
  return typeof maybe.timeout === "function" ? maybe.timeout(ms) : undefined
}

const createMaintenanceHtml = (message: string | null): string => {
  const safeMessage = escapeHtml(
    message && message.trim().length > 0
      ? message
      : "ただいまメンテナンス中です。しばらくしてから再度お試しください。",
  )

  return `<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="robots" content="noindex,nofollow,noarchive" />
    <title>メンテナンス中 | Aipictors</title>
    <style>
      :root { color-scheme: light dark; }
      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #0b1220;
        color: #e2e8f0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }
      .wrap {
        width: min(720px, 92vw);
        padding: 24px;
        text-align: center;
      }
      img {
        width: min(360px, 78vw);
        height: auto;
        display: block;
        margin: 0 auto 18px;
      }
      .msg {
        white-space: pre-wrap;
        font-size: 16px;
        line-height: 1.7;
        opacity: 0.95;
      }
    </style>
  </head>
  <body>
    <main class="wrap">
      <img src="https://assets.aipictors.com/sorrypictorchan.webp" alt="maintenance" />
      <div class="msg">${safeMessage}</div>
    </main>
  </body>
</html>`
}

const getMaintenanceStatus = async (
  ctx: Parameters<PagesFunction>[0],
): Promise<{ isMaintenance: boolean; message: string | null }> => {
  // キャッシュ（短時間）でGraphQLへの負荷を下げる
  // NOTE: Cache API の put はTTLが効かず永続化しやすいので、payload内のcachedAtで期限判定する。
  const cacheTtlMs = 30_000
  const cacheKey = new Request(
    "https://edge-cache.aipictors.invalid/maintenance-status-web",
    { method: "GET" },
  )
  let staleFallback: { isMaintenance: boolean; message: string | null } | null =
    null
  try {
    const cached = await caches.default.match(cacheKey)
    if (cached) {
      try {
        const data = (await cached.json()) as {
          isMaintenance: boolean
          message: string | null
          cachedAt?: number
        }
        staleFallback = {
          isMaintenance: data.isMaintenance,
          message: data.message,
        }
        if (typeof data.cachedAt === "number") {
          const age = Date.now() - data.cachedAt
          if (age >= 0 && age < cacheTtlMs) {
            return { isMaintenance: data.isMaintenance, message: data.message }
          }
        }
      } catch {
        // ignore cache parse error
      }
    }
  } catch {
    // ignore cache access error
  }

  const endpoint = getGraphqlEndpoint(ctx)
  if (!endpoint) {
    return { isMaintenance: false, message: null }
  }

  try {
    const res = await fetch(endpoint, {
      method: "POST",
      headers: {
        "content-type": "application/json",
        provider: "aipictors",
        platform: "web",
      },
      signal: getTimeoutSignal(3000),
      body: JSON.stringify({ query: MAINTENANCE_STATUS_QUERY, variables: {} }),
    })

    if (!res.ok) {
      return { isMaintenance: false, message: null }
    }

    const json = (await res.json()) as {
      data?: {
        maintenanceStatus?: {
          isMaintenanceModeWeb?: boolean
          maintenanceMessageWeb?: string | null
        } | null
      }
    }

    const isMaintenance =
      json.data?.maintenanceStatus?.isMaintenanceModeWeb === true
    const message = json.data?.maintenanceStatus?.maintenanceMessageWeb ?? null

    const payload = { isMaintenance, message, cachedAt: Date.now() }
    try {
      ctx.waitUntil(
        caches.default.put(
          cacheKey,
          new Response(JSON.stringify(payload), {
            status: 200,
            headers: {
              "Content-Type": "application/json",
              "Cache-Control": "no-store",
            },
          }),
        ),
      )
    } catch {
      // ignore cache put error
    }

    return payload
  } catch {
    return staleFallback ?? { isMaintenance: false, message: null }
  }
}

export const onRequest: PagesFunction = async (ctx) => {
  const maxRetry = 5 // リトライ回数を増加
  const baseDelay = 300 // 基本遅延時間を若干増加
  const maxDelay = 8000 // 最大遅延時間を増加
  const timeoutMs = 45000 // 45秒のタイムアウトに延長

  // 基本的な健全性チェック
  try {
    if (!ctx || !ctx.request) {
      throw new Error("Invalid request context")
    }

    const url = new URL(ctx.request.url)
    console.log(`Processing request: ${ctx.request.method} ${url.pathname}`)
  } catch (healthCheckError) {
    console.error("Health check failed:", healthCheckError)
    return new Response(
      JSON.stringify({
        error: "Invalid request",
        code: "BAD_REQUEST",
      }),
      {
        status: 400,
        headers: {
          "Content-Type": "application/json",
        },
      },
    )
  }

  // メンテナンスモード時はSEOに配慮して 503 を返す（noindex + Retry-After）
  // NOTE: リダイレクトではなく同一URLでメンテ表示することで、検索エンジンへ
  // 「一時的な停止」であることを正しく伝えやすくする。
  const { isMaintenance, message } = await getMaintenanceStatus(ctx)
  if (isMaintenance) {
    if (isHtmlNavigationRequest(ctx.request)) {
      return new Response(createMaintenanceHtml(message), {
        status: 503,
        headers: {
          "Content-Type": "text/html; charset=utf-8",
          "Cache-Control": "no-store",
          "Retry-After": "300",
          "X-Robots-Tag": "noindex, nofollow, noarchive",
        },
      })
    }

    return new Response(
      JSON.stringify({
        error: "MAINTENANCE",
        message: message,
      }),
      {
        status: 503,
        headers: {
          "Content-Type": "application/json",
          "Cache-Control": "no-store",
          "Retry-After": "300",
          "X-Robots-Tag": "noindex, nofollow, noarchive",
        },
      },
    )
  }

  /**
   * Error 1101やDB接続エラーを検出する
   */
  const isRetryableError = (error: unknown): boolean => {
    const errorMessage = error instanceof Error ? error.message : String(error)
    return (
      errorMessage.includes("1101") ||
      errorMessage.includes("Worker threw exception") ||
      errorMessage.includes("database") ||
      errorMessage.includes("timeout") ||
      errorMessage.includes("connection") ||
      errorMessage.includes("ECONNRESET") ||
      errorMessage.includes("ENOTFOUND") ||
      errorMessage.includes("ETIMEDOUT") ||
      errorMessage.includes("socket hang up") ||
      errorMessage.includes("network") ||
      errorMessage.includes("502") ||
      errorMessage.includes("503") ||
      errorMessage.includes("504") ||
      errorMessage.includes("Rate limit") ||
      errorMessage.includes("Too many requests") ||
      // CloudFlare関連エラー
      errorMessage.includes("cloudflare") ||
      errorMessage.includes("CF-") ||
      // メモリ関連エラー
      errorMessage.includes("out of memory") ||
      errorMessage.includes("memory limit")
    )
  }

  /**
   * タイムアウト付きでリクエストを実行する
   */
  const executeWithTimeout = async (
    request: Promise<Response>,
  ): Promise<Response> => {
    const timeoutPromise = new Promise<never>((_, reject) => {
      setTimeout(() => reject(new Error("Request timeout")), timeoutMs)
    })

    return Promise.race([request, timeoutPromise])
  }

  for (let attempt = 0; attempt < maxRetry; attempt++) {
    try {
      const res = await executeWithTimeout(remix(ctx))

      // IMPORTANT:
      // Do not consume the body (e.g. res.text()), otherwise binary responses
      // like images/zip will be corrupted.
      return res
    } catch (err) {
      console.error(`Request attempt ${attempt + 1}/${maxRetry} failed:`, err)
      console.error(
        `Error type: ${err instanceof Error ? err.constructor.name : typeof err}`,
      )
      console.error(
        `Error message: ${err instanceof Error ? err.message : String(err)}`,
      )
      console.error(
        `Stack trace: ${err instanceof Error ? err.stack : "No stack trace available"}`,
      )

      // リトライ可能なエラーかどうかを判定
      if (!isRetryableError(err)) {
        // リトライ不可能なエラーの場合は即座にエラーを返す
        return new Response(
          JSON.stringify({
            error: "Internal server error",
            code: "INTERNAL_ERROR",
          }),
          {
            status: 500,
            headers: {
              "Content-Type": "application/json",
            },
          },
        )
      }

      // 最後の試行の場合はエラーを返す
      if (attempt === maxRetry - 1) {
        const errorDetails = err instanceof Error ? err.message : String(err)
        console.error(
          `All ${maxRetry} attempts failed. Final error:`,
          errorDetails,
        )

        return new Response(
          JSON.stringify({
            error: "Service temporarily unavailable. Please try again later.",
            code: "TEMPORARY_UNAVAILABLE",
            details: import.meta.env.DEV ? errorDetails : undefined, // 開発環境でのみ詳細を表示
            timestamp: new Date().toISOString(),
          }),
          {
            status: 503,
            headers: {
              "Content-Type": "application/json",
              "Retry-After": "30",
            },
          },
        )
      }

      // 指数バックオフで遅延時間を増加させる
      const delay = Math.min(baseDelay * 2 ** attempt, maxDelay)
      // ジッターを追加して同時リクエストの集中を防ぐ
      const jitter = Math.random() * 0.3 * delay
      const actualDelay = delay + jitter

      await new Promise((resolve) => setTimeout(resolve, actualDelay))
    }
  }

  // この行に到達することはないが、TypeScriptの型チェックのために残す
  return new Response("Unexpected error", { status: 500 })
}
