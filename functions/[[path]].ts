import { createPagesFunctionHandler } from "@remix-run/cloudflare-pages"
// @ts-ignore - the server build file is generated by `remix vite:build`
import * as build from "../build/server"

const remix = createPagesFunctionHandler({
  build,
})

const MAINTENANCE_STATUS_QUERY = `query MaintenanceStatus {
  maintenanceStatus {
    isMaintenanceModeWeb
    maintenanceMessageWeb
  }
}`

const escapeHtml = (value: string): string => {
  return value
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#39;")
}

const getGraphqlEndpoint = (
  ctx: Parameters<PagesFunction>[0],
): string | null => {
  const env = ctx.env as unknown as Record<string, unknown>
  const remixEndpoint =
    typeof env["VITE_GRAPHQL_ENDPOINT_REMIX"] === "string"
      ? (env["VITE_GRAPHQL_ENDPOINT_REMIX"] as string)
      : null
  const browserEndpoint =
    typeof env["VITE_GRAPHQL_ENDPOINT"] === "string"
      ? (env["VITE_GRAPHQL_ENDPOINT"] as string)
      : null
  return remixEndpoint ?? browserEndpoint ?? null
}

const getEnvKeys = (ctx: Parameters<PagesFunction>[0]): string[] => {
  try {
    const env = ctx.env as unknown as Record<string, unknown>
    return Object.keys(env).sort().slice(0, 50)
  } catch {
    return []
  }
}

const isHtmlNavigationRequest = (request: Request): boolean => {
  const method = request.method.toUpperCase()
  if (method !== "GET" && method !== "HEAD") return false
  const accept = request.headers.get("accept") ?? ""
  // ブラウザの通常ナビゲーションを主対象にする
  return accept.includes("text/html") || accept.includes("*/*")
}

const getTimeoutSignal = (ms: number): AbortSignal | undefined => {
  const maybe = AbortSignal as unknown as {
    timeout?: (timeoutMs: number) => AbortSignal
  }
  return typeof maybe.timeout === "function" ? maybe.timeout(ms) : undefined
}

const createMaintenanceHtml = (message: string | null): string => {
  const safeMessage = escapeHtml(
    message && message.trim().length > 0
      ? message
      : "ただいまメンテナンス中です。しばらくしてから再度お試しください。",
  )

  return `<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="robots" content="noindex,nofollow,noarchive" />
    <title>メンテナンス中 | Aipictors</title>
    <style>
      :root { color-scheme: light dark; }
      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #0b1220;
        color: #e2e8f0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }
      .wrap {
        width: min(720px, 92vw);
        padding: 24px;
        text-align: center;
      }
      img {
        width: min(360px, 78vw);
        height: auto;
        display: block;
        margin: 0 auto 18px;
      }
      .msg {
        white-space: pre-wrap;
        font-size: 16px;
        line-height: 1.7;
        opacity: 0.95;
      }
    </style>
  </head>
  <body>
    <main class="wrap">
      <img src="https://assets.aipictors.com/sorrypictorchan.webp" alt="maintenance" />
      <div class="msg">${safeMessage}</div>
    </main>
  </body>
</html>`
}

const ADMIN_HOSTNAMES = new Set(["admin.aipictors.com"])

const readEnvString = (
  ctx: Parameters<PagesFunction>[0],
  key: string,
): string | null => {
  const env = ctx.env as unknown as Record<string, unknown>
  const value = env[key]
  return typeof value === "string" && value.length > 0 ? value : null
}

const decodeBasicAuth = (
  authorizationHeader: string | null,
): { username: string; password: string } | null => {
  if (!authorizationHeader) return null
  const [scheme, encoded] = authorizationHeader.split(" ")
  if (scheme?.toLowerCase() !== "basic" || !encoded) return null

  try {
    const decoded = atob(encoded)
    const index = decoded.indexOf(":")
    if (index < 0) return null
    return {
      username: decoded.slice(0, index),
      password: decoded.slice(index + 1),
    }
  } catch {
    return null
  }
}

const createBasicAuthChallengeResponse = (): Response => {
  return new Response("Unauthorized", {
    status: 401,
    headers: {
      "WWW-Authenticate": 'Basic realm="Aipictors Admin"',
      "Cache-Control": "no-store",
    },
  })
}

type MaintenanceStatusPayload = {
  isMaintenance: boolean
  message: string | null
}

type MaintenanceStatusDebug = {
  endpoint: string | null
  cache: {
    hit: boolean
    cachedAt?: number
    ageMs?: number
    used: boolean
  }
  fetch: {
    attempted: boolean
    ok?: boolean
    status?: number
    error?: string
    hasGraphqlErrors?: boolean
    firstGraphqlErrorCode?: string
    firstGraphqlErrorNumber?: number
  }
}

const getMaintenanceStatus = async (
  ctx: Parameters<PagesFunction>[0],
  options?: { debug?: boolean },
): Promise<MaintenanceStatusPayload & { debug?: MaintenanceStatusDebug }> => {
  // キャッシュ（短時間）でGraphQLへの負荷を下げる
  // NOTE: Cache API の put はTTLが効かず永続化しやすいので、payload内のcachedAtで期限判定する。
  const cacheTtlMs = 30_000
  const cacheKey = new Request(
    "https://edge-cache.aipictors.invalid/maintenance-status-web",
    { method: "GET" },
  )
  let staleFallback: { isMaintenance: boolean; message: string | null } | null =
    null

  const debug: MaintenanceStatusDebug | undefined = options?.debug
    ? {
        endpoint: null,
        cache: { hit: false, used: false },
        fetch: { attempted: false },
      }
    : undefined

  try {
    const cached = await caches.default.match(cacheKey)
    if (cached) {
      try {
        const data = (await cached.json()) as {
          isMaintenance: boolean
          message: string | null
          cachedAt?: number
        }
        staleFallback = {
          isMaintenance: data.isMaintenance,
          message: data.message,
        }

        if (debug) {
          debug.cache.hit = true
          debug.cache.cachedAt = data.cachedAt
          if (typeof data.cachedAt === "number") {
            debug.cache.ageMs = Date.now() - data.cachedAt
          }
        }

        if (typeof data.cachedAt === "number") {
          const age = Date.now() - data.cachedAt
          if (age >= 0 && age < cacheTtlMs) {
            if (debug) debug.cache.used = true
            return {
              isMaintenance: data.isMaintenance,
              message: data.message,
              debug,
            }
          }
        }
      } catch {
        // ignore cache parse error
      }
    }
  } catch {
    // ignore cache access error
  }

  const endpoint = getGraphqlEndpoint(ctx)
  if (!endpoint) {
    if (debug) debug.endpoint = null
    return { isMaintenance: false, message: null, debug }
  }

  if (debug) debug.endpoint = endpoint

  try {
    const res = await fetch(endpoint, {
      method: "POST",
      headers: {
        "content-type": "application/json",
        provider: "aipictors",
        platform: "web",
      },
      signal: getTimeoutSignal(3000),
      body: JSON.stringify({ query: MAINTENANCE_STATUS_QUERY, variables: {} }),
    })

    if (debug) {
      debug.fetch.attempted = true
      debug.fetch.ok = res.ok
      debug.fetch.status = res.status
    }

    if (!res.ok) {
      return { isMaintenance: false, message: null, debug }
    }

    const json = (await res.json()) as {
      errors?: Array<{
        message?: string
        extensions?: { code?: string; number?: number }
      }>
      data?: {
        maintenanceStatus?: {
          isMaintenanceModeWeb?: boolean
          maintenanceMessageWeb?: string | null
        } | null
      } | null
    }

    const hasGraphqlErrors =
      Array.isArray(json.errors) && json.errors.length > 0
    if (debug) {
      debug.fetch.hasGraphqlErrors = hasGraphqlErrors
      const first = hasGraphqlErrors ? json.errors?.[0] : undefined
      if (first?.extensions?.code) {
        debug.fetch.firstGraphqlErrorCode = first.extensions.code
      }
      if (typeof first?.extensions?.number === "number") {
        debug.fetch.firstGraphqlErrorNumber = first.extensions.number
      }
    }

    // GraphQLが200でも errors/data:null が返る場合がある。
    // その場合は「判定不能」なので、キャッシュがあればそれを使い、無ければ
    // サービス不調としてメンテ表示にフェイルオープンする。
    const status = json.data?.maintenanceStatus ?? null
    if (hasGraphqlErrors || !status) {
      if (staleFallback) {
        return {
          isMaintenance: staleFallback.isMaintenance,
          message: staleFallback.message,
          debug,
        }
      }

      return {
        isMaintenance: true,
        message:
          "ただいまメンテナンス中です。しばらくしてから再度お試しください。",
        debug,
      }
    }

    const isMaintenance = status.isMaintenanceModeWeb === true
    const message = status.maintenanceMessageWeb ?? null

    const payload = { isMaintenance, message, cachedAt: Date.now() }
    try {
      ctx.waitUntil(
        caches.default.put(
          cacheKey,
          new Response(JSON.stringify(payload), {
            status: 200,
            headers: {
              "Content-Type": "application/json",
              "Cache-Control": "no-store",
            },
          }),
        ),
      )
    } catch {
      // ignore cache put error
    }

    return {
      isMaintenance: payload.isMaintenance,
      message: payload.message,
      debug,
    }
  } catch (error) {
    if (debug) {
      debug.fetch.attempted = true
      debug.fetch.error = error instanceof Error ? error.message : String(error)
    }
    const fallback = staleFallback ?? { isMaintenance: false, message: null }
    return {
      isMaintenance: fallback.isMaintenance,
      message: fallback.message,
      debug,
    }
  }
}

export const onRequest: PagesFunction = async (ctx) => {
  const maxRetry = 5 // リトライ回数を増加
  const baseDelay = 300 // 基本遅延時間を若干増加
  const maxDelay = 8000 // 最大遅延時間を増加
  const timeoutMs = 45000 // 45秒のタイムアウトに延長

  // NOTE: メンテナンス表示を一時的に無効化
  // メンテON/OFF直後にエッジキャッシュやGraphQL取得失敗時のフェイルオープンで
  // 「表示されたりされなかったり」が起きやすいので、実装側では常に通常表示に寄せる。
  // （戻す場合は false に戻すだけでOK）
  const MAINTENANCE_PAGE_DISABLED = true

  // 基本的な健全性チェック
  try {
    if (!ctx || !ctx.request) {
      throw new Error("Invalid request context")
    }

    const url = new URL(ctx.request.url)
    console.log(`Processing request: ${ctx.request.method} ${url.pathname}`)

    // 本番切り分け用: ?__maintenance_debug=1 で判定材料をJSONで返す
    if (url.searchParams.get("__maintenance_debug") === "1") {
      const env = ctx.env as unknown as Record<string, unknown>
      const hasViteGraphqlEndpointRemix =
        typeof env["VITE_GRAPHQL_ENDPOINT_REMIX"] === "string"
      const hasViteGraphqlEndpoint =
        typeof env["VITE_GRAPHQL_ENDPOINT"] === "string"

      const result = await getMaintenanceStatus(ctx, { debug: true })
      return new Response(
        JSON.stringify(
          {
            method: ctx.request.method,
            pathname: url.pathname,
            host: url.host,
            accept: ctx.request.headers.get("accept"),
            isHtmlNavigation: isHtmlNavigationRequest(ctx.request),
            envKeys: getEnvKeys(ctx),
            hasViteGraphqlEndpointRemix,
            hasViteGraphqlEndpoint,
            ...result,
          },
          null,
          2,
        ),
        {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Cache-Control": "no-store",
            "X-Robots-Tag": "noindex, nofollow, noarchive",
          },
        },
      )
    }
  } catch (healthCheckError) {
    console.error("Health check failed:", healthCheckError)
    return new Response(
      JSON.stringify({
        error: "Invalid request",
        code: "BAD_REQUEST",
      }),
      {
        status: 400,
        headers: {
          "Content-Type": "application/json",
        },
      },
    )
  }

  // admin.aipictors.com は Basic 認証を必須にする
  // NOTE: Remix の loader/action より先に弾くため、Pages Functions 側で実施する。
  const requestUrl = new URL(ctx.request.url)
  if (ADMIN_HOSTNAMES.has(requestUrl.hostname)) {
    const expectedUser =
      readEnvString(ctx, "ADMIN_BASIC_AUTH_USER") ??
      readEnvString(ctx, "ADMIN_BASIC_USER")
    const expectedPass =
      readEnvString(ctx, "ADMIN_BASIC_AUTH_PASSWORD") ??
      readEnvString(ctx, "ADMIN_BASIC_PASSWORD")

    // 誤設定で無防備にならないよう、資格情報未設定は 500 で落とす
    if (!expectedUser || !expectedPass) {
      return new Response(
        JSON.stringify({
          error: "Admin basic auth is not configured",
          code: "ADMIN_BASIC_AUTH_NOT_CONFIGURED",
        }),
        {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Cache-Control": "no-store",
          },
        },
      )
    }

    const credentials = decodeBasicAuth(
      ctx.request.headers.get("authorization"),
    )

    if (
      !credentials ||
      credentials.username !== expectedUser ||
      credentials.password !== expectedPass
    ) {
      return createBasicAuthChallengeResponse()
    }

    // adminドメインの / は管理画面へ寄せる
    if (requestUrl.pathname === "/") {
      return Response.redirect(new URL("/admin/works", requestUrl).toString(), 302)
    }
  }

  // メンテナンスモード時はSEOに配慮して 503 を返す（noindex + Retry-After）
  // NOTE: リダイレクトではなく同一URLでメンテ表示することで、検索エンジンへ
  // 「一時的な停止」であることを正しく伝えやすくする。
  const { isMaintenance: rawIsMaintenance, message } =
    await getMaintenanceStatus(ctx)
  const isMaintenance = MAINTENANCE_PAGE_DISABLED ? false : rawIsMaintenance
  if (isMaintenance) {
    if (isHtmlNavigationRequest(ctx.request)) {
      return new Response(createMaintenanceHtml(message), {
        status: 503,
        headers: {
          "Content-Type": "text/html; charset=utf-8",
          "Cache-Control": "no-store",
          "Retry-After": "300",
          "X-Robots-Tag": "noindex, nofollow, noarchive",
        },
      })
    }

    return new Response(
      JSON.stringify({
        error: "MAINTENANCE",
        message: message,
      }),
      {
        status: 503,
        headers: {
          "Content-Type": "application/json",
          "Cache-Control": "no-store",
          "Retry-After": "300",
          "X-Robots-Tag": "noindex, nofollow, noarchive",
        },
      },
    )
  }

  /**
   * Error 1101やDB接続エラーを検出する
   */
  const isRetryableError = (error: unknown): boolean => {
    const errorMessage = error instanceof Error ? error.message : String(error)
    return (
      errorMessage.includes("1101") ||
      errorMessage.includes("Worker threw exception") ||
      errorMessage.includes("database") ||
      errorMessage.includes("timeout") ||
      errorMessage.includes("connection") ||
      errorMessage.includes("ECONNRESET") ||
      errorMessage.includes("ENOTFOUND") ||
      errorMessage.includes("ETIMEDOUT") ||
      errorMessage.includes("socket hang up") ||
      errorMessage.includes("network") ||
      errorMessage.includes("502") ||
      errorMessage.includes("503") ||
      errorMessage.includes("504") ||
      errorMessage.includes("Rate limit") ||
      errorMessage.includes("Too many requests") ||
      // CloudFlare関連エラー
      errorMessage.includes("cloudflare") ||
      errorMessage.includes("CF-") ||
      // メモリ関連エラー
      errorMessage.includes("out of memory") ||
      errorMessage.includes("memory limit")
    )
  }

  /**
   * タイムアウト付きでリクエストを実行する
   */
  const executeWithTimeout = async (
    request: Promise<Response>,
  ): Promise<Response> => {
    const timeoutPromise = new Promise<never>((_, reject) => {
      setTimeout(() => reject(new Error("Request timeout")), timeoutMs)
    })

    return Promise.race([request, timeoutPromise])
  }

  for (let attempt = 0; attempt < maxRetry; attempt++) {
    try {
      const res = await executeWithTimeout(remix(ctx))

      // IMPORTANT:
      // Do not consume the body (e.g. res.text()), otherwise binary responses
      // like images/zip will be corrupted.
      return res
    } catch (err) {
      console.error(`Request attempt ${attempt + 1}/${maxRetry} failed:`, err)
      console.error(
        `Error type: ${err instanceof Error ? err.constructor.name : typeof err}`,
      )
      console.error(
        `Error message: ${err instanceof Error ? err.message : String(err)}`,
      )
      console.error(
        `Stack trace: ${err instanceof Error ? err.stack : "No stack trace available"}`,
      )

      // リトライ可能なエラーかどうかを判定
      if (!isRetryableError(err)) {
        // リトライ不可能なエラーの場合は即座にエラーを返す
        return new Response(
          JSON.stringify({
            error: "Internal server error",
            code: "INTERNAL_ERROR",
          }),
          {
            status: 500,
            headers: {
              "Content-Type": "application/json",
            },
          },
        )
      }

      // 最後の試行の場合はエラーを返す
      if (attempt === maxRetry - 1) {
        const errorDetails = err instanceof Error ? err.message : String(err)
        console.error(
          `All ${maxRetry} attempts failed. Final error:`,
          errorDetails,
        )

        return new Response(
          JSON.stringify({
            error: "Service temporarily unavailable. Please try again later.",
            code: "TEMPORARY_UNAVAILABLE",
            details: import.meta.env.DEV ? errorDetails : undefined, // 開発環境でのみ詳細を表示
            timestamp: new Date().toISOString(),
          }),
          {
            status: 503,
            headers: {
              "Content-Type": "application/json",
              "Retry-After": "30",
            },
          },
        )
      }

      // 指数バックオフで遅延時間を増加させる
      const delay = Math.min(baseDelay * 2 ** attempt, maxDelay)
      // ジッターを追加して同時リクエストの集中を防ぐ
      const jitter = Math.random() * 0.3 * delay
      const actualDelay = delay + jitter

      await new Promise((resolve) => setTimeout(resolve, actualDelay))
    }
  }

  // この行に到達することはないが、TypeScriptの型チェックのために残す
  return new Response("Unexpected error", { status: 500 })
}
