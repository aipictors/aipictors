import { createPagesFunctionHandler } from "@remix-run/cloudflare-pages"
// @ts-ignore - the server build file is generated by `remix vite:build`
import * as build from "../build/server"

const remix = createPagesFunctionHandler({
  build,
})

export const onRequest: PagesFunction = async (ctx) => {
  const maxRetry = 5 // リトライ回数を増加
  const baseDelay = 300 // 基本遅延時間を若干増加
  const maxDelay = 8000 // 最大遅延時間を増加
  const timeoutMs = 45000 // 45秒のタイムアウトに延長

  // 基本的な健全性チェック
  try {
    if (!ctx || !ctx.request) {
      throw new Error("Invalid request context")
    }

    const url = new URL(ctx.request.url)
    console.log(`Processing request: ${ctx.request.method} ${url.pathname}`)
  } catch (healthCheckError) {
    console.error("Health check failed:", healthCheckError)
    return new Response(
      JSON.stringify({
        error: "Invalid request",
        code: "BAD_REQUEST",
      }),
      {
        status: 400,
        headers: {
          "Content-Type": "application/json",
        },
      },
    )
  }

  /**
   * Error 1101やDB接続エラーを検出する
   */
  const isRetryableError = (error: unknown): boolean => {
    const errorMessage = error instanceof Error ? error.message : String(error)
    return (
      errorMessage.includes("1101") ||
      errorMessage.includes("Worker threw exception") ||
      errorMessage.includes("database") ||
      errorMessage.includes("timeout") ||
      errorMessage.includes("connection") ||
      errorMessage.includes("ECONNRESET") ||
      errorMessage.includes("ENOTFOUND") ||
      errorMessage.includes("ETIMEDOUT") ||
      errorMessage.includes("socket hang up") ||
      errorMessage.includes("network") ||
      errorMessage.includes("502") ||
      errorMessage.includes("503") ||
      errorMessage.includes("504") ||
      errorMessage.includes("Rate limit") ||
      errorMessage.includes("Too many requests") ||
      // CloudFlare関連エラー
      errorMessage.includes("cloudflare") ||
      errorMessage.includes("CF-") ||
      // メモリ関連エラー
      errorMessage.includes("out of memory") ||
      errorMessage.includes("memory limit")
    )
  }

  /**
   * タイムアウト付きでリクエストを実行する
   */
  const executeWithTimeout = async (
    request: Promise<Response>,
  ): Promise<Response> => {
    const timeoutPromise = new Promise<never>((_, reject) => {
      setTimeout(() => reject(new Error("Request timeout")), timeoutMs)
    })

    return Promise.race([request, timeoutPromise])
  }

  for (let attempt = 0; attempt < maxRetry; attempt++) {
    try {
      const res = await executeWithTimeout(remix(ctx))

      // IMPORTANT:
      // Do not consume the body (e.g. res.text()), otherwise binary responses
      // like images/zip will be corrupted.
      return res
    } catch (err) {
      console.error(`Request attempt ${attempt + 1}/${maxRetry} failed:`, err)
      console.error(
        `Error type: ${err instanceof Error ? err.constructor.name : typeof err}`,
      )
      console.error(
        `Error message: ${err instanceof Error ? err.message : String(err)}`,
      )
      console.error(
        `Stack trace: ${err instanceof Error ? err.stack : "No stack trace available"}`,
      )

      // リトライ可能なエラーかどうかを判定
      if (!isRetryableError(err)) {
        // リトライ不可能なエラーの場合は即座にエラーを返す
        return new Response(
          JSON.stringify({
            error: "Internal server error",
            code: "INTERNAL_ERROR",
          }),
          {
            status: 500,
            headers: {
              "Content-Type": "application/json",
            },
          },
        )
      }

      // 最後の試行の場合はエラーを返す
      if (attempt === maxRetry - 1) {
        const errorDetails = err instanceof Error ? err.message : String(err)
        console.error(
          `All ${maxRetry} attempts failed. Final error:`,
          errorDetails,
        )

        return new Response(
          JSON.stringify({
            error: "Service temporarily unavailable. Please try again later.",
            code: "TEMPORARY_UNAVAILABLE",
            details: import.meta.env.DEV ? errorDetails : undefined, // 開発環境でのみ詳細を表示
            timestamp: new Date().toISOString(),
          }),
          {
            status: 503,
            headers: {
              "Content-Type": "application/json",
              "Retry-After": "30",
            },
          },
        )
      }

      // 指数バックオフで遅延時間を増加させる
      const delay = Math.min(baseDelay * 2 ** attempt, maxDelay)
      // ジッターを追加して同時リクエストの集中を防ぐ
      const jitter = Math.random() * 0.3 * delay
      const actualDelay = delay + jitter

      await new Promise((resolve) => setTimeout(resolve, actualDelay))
    }
  }

  // この行に到達することはないが、TypeScriptの型チェックのために残す
  return new Response("Unexpected error", { status: 500 })
}
